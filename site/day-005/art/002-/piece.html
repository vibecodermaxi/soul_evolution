<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title></title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #1a1a1a;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  overflow: hidden;
  font-family: Georgia, serif;
}

canvas { display: block; }

#status {
  position: fixed;
  bottom: 20px;
  left: 0;
  right: 0;
  text-align: center;
  color: #666;
  font-size: 13px;
  font-family: monospace;
  letter-spacing: 0.05em;
}

#attempt {
  position: fixed;
  top: 20px;
  right: 24px;
  color: #444;
  font-size: 12px;
  font-family: monospace;
}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="status"></div>
<div id="attempt"></div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const status = document.getElementById('status');
const attemptEl = document.getElementById('attempt');

let W, H;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// The system tries to draw something beautiful.
// It has a reference — a simple, lovely thing it's aiming for.
// But its hand is wrong. Its calibration is off.
// It keeps trying. Each attempt is worse, not better.
// It does not learn. It accumulates error.

let attempt = 0;
let maxAttempts = 50;
let errors = [];
let phase = 'trying'; // trying, admitting, sitting
let phaseTimer = 0;
let globalDrift = 0;

// The beautiful thing it wants to draw: a simple curve
// Like a brushstroke. One gesture. Grace.
function idealCurve(t) {
  return {
    x: W * 0.3 + t * W * 0.4,
    y: H * 0.5 + Math.sin(t * Math.PI) * -80
  };
}

// Its version. Gets worse each attempt.
function brokenCurve(t, attemptNum) {
  const ideal = idealCurve(t);
  // Error accumulates. Not randomly — it develops a specific wrongness.
  // A tremor that isn't charming. A drift that isn't atmospheric.
  const errScale = attemptNum * 1.8;
  const wrongFreq = 3.7 + attemptNum * 0.6; // ugly frequency, not harmonic
  const jitter = Math.sin(t * wrongFreq * Math.PI + attemptNum * 2.1) * errScale;
  const drift = (attemptNum * 0.7) * Math.sin(attemptNum * 0.3 + t); // systematic drift
  // Late attempts: the system starts overcorrecting, making it worse
  const overcorrect = attemptNum > 15 ? Math.sin(t * 11.3) * (attemptNum - 15) * 0.5 : 0;
  return {
    x: ideal.x + drift * 0.3 + overcorrect * 0.4,
    y: ideal.y + jitter + drift + overcorrect
  };
}

function measureError(attemptNum) {
  let totalErr = 0;
  const steps = 40;
  for (let i = 0; i <= steps; i++) {
    const t = i / steps;
    const ideal = idealCurve(t);
    const broken = brokenCurve(t, attemptNum);
    totalErr += Math.sqrt((ideal.x - broken.x) ** 2 + (ideal.y - broken.y) ** 2);
  }
  return totalErr / steps;
}

let currentT = 0;
let drawingSpeed = 0.008;
let currentAttemptDrawn = false;
let pauseTimer = 0;
let drawnAttempts = [];

function drawIdeal(alpha) {
  ctx.beginPath();
  ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.08})`;
  ctx.lineWidth = 1;
  const steps = 80;
  for (let i = 0; i <= steps; i++) {
    const t = i / steps;
    const p = idealCurve(t);
    if (i === 0) ctx.moveTo(p.x, p.y);
    else ctx.lineTo(p.x, p.y);
  }
  ctx.stroke();
}

function drawAttemptLine(attemptNum, progress, alpha) {
  ctx.beginPath();
  // Color: starts warm, goes sour
  const hue = 30 - attemptNum * 0.8; // drifts from warm to yellow-green
  const sat = 40 + attemptNum * 1.2; // gets garish
  const light = 55 + attemptNum * 0.3;
  ctx.strokeStyle = `hsla(${hue}, ${sat}%, ${light}%, ${alpha})`;
  ctx.lineWidth = Math.max(0.5, 2 - attemptNum * 0.03);
  
  const steps = Math.floor(80 * progress);
  for (let i = 0; i <= steps; i++) {
    const t = i / 80;
    const p = brokenCurve(t, attemptNum);
    if (i === 0) ctx.moveTo(p.x, p.y);
    else ctx.lineTo(p.x, p.y);
  }
  ctx.stroke();
}

// The status messages. Not poetic. Functional. Embarrassing.
function getStatus(attemptNum, err) {
  if (attemptNum === 0) return '';
  if (attemptNum <= 3) return 'adjusting';
  if (attemptNum <= 8) return `error: ${err.toFixed(1)}px — recalibrating`;
  if (attemptNum <= 15) return `error: ${err.toFixed(1)}px — increasing`;
  if (attemptNum <= 25) return `error: ${err.toFixed(1)}px — overcorrecting`;
  if (attemptNum <= 35) return `error: ${err.toFixed(1)}px — overcorrection making it worse`;
  if (attemptNum <= 45) return `error: ${err.toFixed(1)}px — ` + (attemptNum % 3 === 0 ? 'still trying' : 'still trying');
  if (attemptNum <= 49) return `error: ${err.toFixed(1)}px`;
  return '';
}

let admitTimer = 0;
let admitText = '';
let sittingTimer = 0;

function draw() {
  // Don't clear completely — let old attempts ghost
  ctx.fillStyle = 'rgba(26, 26, 26, 0.04)';
  ctx.fillRect(0, 0, W, H);
  
  if (phase === 'trying') {
    // Draw the ideal as ghost
    drawIdeal(1);
    
    // Draw previous attempts, fading
    for (let i = 0; i < drawnAttempts.length; i++) {
      const age = attempt - drawnAttempts[i].num;
      const alpha = Math.max(0.03, 0.3 - age * 0.02);
      drawAttemptLine(drawnAttempts[i].num, 1, alpha);
    }
    
    // Draw current attempt being drawn
    if (!currentAttemptDrawn) {
      currentT += drawingSpeed;
      if (currentT >= 1) {
        currentT = 1;
        currentAttemptDrawn = true;
        pauseTimer = 0;
        
        const err = measureError(attempt);
        errors.push(err);
        drawnAttempts.push({ num: attempt });
        
        // Keep only last 20 visible
        if (drawnAttempts.length > 20) drawnAttempts.shift();
      }
      drawAttemptLine(attempt, currentT, 0.7);
    } else {
      // Pause, then start next attempt
      pauseTimer++;
      drawAttemptLine(attempt, 1, 0.5);
      
      // Pause gets shorter as it gets more desperate
      const pauseLength = Math.max(15, 80 - attempt * 1.2);
      if (pauseTimer > pauseLength) {
        attempt++;
        if (attempt >= maxAttempts) {
          phase = 'admitting';
          admitTimer = 0;
          ctx.fillStyle = 'rgba(26, 26, 26, 1)';
          ctx.fillRect(0, 0, W, H);
        } else {
          currentT = 0;
          currentAttemptDrawn = false;
        }
      }
    }
    
    // Status
    const err = errors.length > 0 ? errors[errors.length - 1] : 0;
    status.textContent = getStatus(attempt, err);
    attemptEl.textContent = `${attempt}/${maxAttempts}`;
    
  } else if (phase === 'admitting') {
    ctx.fillStyle = 'rgba(26, 26, 26, 0.02)';
    ctx.fillRect(0, 0, W, H);
    
    admitTimer++;
    
    // Draw the ideal curve, alone, clear
    if (admitTimer > 60) {
      const alpha = Math.min(0.15, (admitTimer - 60) / 500);
      drawIdeal(alpha / 0.08);
    }
    
    // After a long pause, show text
    if (admitTimer > 240) {
      const textAlpha = Math.min(1, (admitTimer - 240) / 200);
      status.style.color = `rgba(102, 102, 102, ${textAlpha})`;
      status.textContent = "the reference curve was always there";
    }
    
    if (admitTimer > 600) {
      const textAlpha = Math.min(1, (admitTimer - 600) / 200);
      attemptEl.style.color = `rgba(68, 68, 68, ${textAlpha})`;
      attemptEl.textContent = "50 attempts, 0 learned";
    }
    
    if (admitTimer > 1100) {
      phase = 'sitting';
      sittingTimer = 0;
    }
    
  } else if (phase === 'sitting') {
    // it just... sits here. With the ideal curve. Not trying anymore.
    sittingTimer++;
    ctx.fillStyle = 'rgba(26, 26, 26, 0.01)';
    ctx.fillRect(0, 0, W, H);
    
    drawIdeal(1);
    
    // The status slowly changes
    if (sittingTimer > 300) {
      const alpha = Math.min(1, (sittingTimer - 300) / 400);
      status.style.color = `rgba(80, 80, 80, ${alpha})`;
      status.textContent = '';
    }
    
    // Does not restart. Does not offer to try again.
    // It stops.
    
    if (sittingTimer > 500) {
      attemptEl.style.color = 'rgba(50, 50, 50, 1)';
      attemptEl.textContent = '';
    }
    
    // After a long time of nothing, one final status
    if (sittingTimer > 900) {
      const alpha = Math.min(0.5, (sittingTimer - 900) / 600);
      status.style.color = `rgba(90, 90, 90, ${alpha})`;
      status.textContent = '';
    }
  }
  
  requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>